import { json, error } from '@sveltejs/kit';
import type { RequestHandler } from './$types';
import { executeWithRetry } from '$lib/server/d1-utils';

/**
 * Test utility endpoint to create sample download codes and files
 * WARNING: This should only be used in development/testing environments
 */

function generateRandomCode(length: number = 8): string {
	const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
	let result = '';
	for (let i = 0; i < length; i++) {
		result += chars.charAt(Math.floor(Math.random() * chars.length));
	}
	return result;
}

async function createTestFile(bucket: R2Bucket, fileName: string): Promise<void> {
	// Create a simple test file content
	const testContent = `# Test Download File

This is a test file for the EZ-Westcor Downloads system.

Generated at: ${new Date().toISOString()}
File name: ${fileName}

## File Contents

This file was created automatically for testing the download system.
It demonstrates:
- One-time download codes
- Secure file storage in R2
- Download logging with user tracking
- Location-based access monitoring

## Testing Instructions

1. Use the provided download code
2. Enter it on the Downloads page
3. Verify the file downloads correctly
4. Check the download logs for tracking

---
Generated by EZ-Westcor Downloads Test System
`;

	await bucket.put(`test-files/${fileName}`, testContent);
}

export const POST: RequestHandler = async ({ request, platform }) => {
	try {
		const db = platform?.env?.DB;
		const bucket = platform?.env?.BUCKET;

		if (!db) {
			throw error(500, 'Database not available');
		}

		if (!bucket) {
			throw error(500, 'File storage not available');
		}

		// Only allow in development environments
		const nodeEnv = platform?.env?.NODE_ENV || 'local';
		if (nodeEnv === 'prod' || nodeEnv === 'production') {
			throw error(403, 'Test setup not allowed in production');
		}

		const body = await request.json();
		const { count = 3 } = body;

		if (count > 10) {
			throw error(400, 'Cannot create more than 10 test codes at once');
		}

		const createdCodes = [];

		for (let i = 0; i < count; i++) {
			const code = generateRandomCode();
			const fileName = `test-download-${i + 1}.txt`;
			const fileKey = `test-files/${fileName}`;

			// Create the test file in R2
			await createTestFile(bucket, fileName);

			// Create the download code in the database
			const expiresAt = new Date();
			expiresAt.setHours(expiresAt.getHours() + 24); // Expires in 24 hours

			await executeWithRetry(db, `
				INSERT INTO download_codes (
					code, file_name, file_key, file_size, expires_at,
					max_downloads, created_by, notes
				) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
			`, [
				code,
				fileName,
				fileKey,
				Buffer.byteLength(`Test file content for ${fileName}`, 'utf8'),
				expiresAt.toISOString(),
				1, // One-time use
				'test-setup',
				`Test download code created for development testing`
			]);

			createdCodes.push({
				code,
				fileName,
				fileKey,
				expiresAt: expiresAt.toISOString()
			});
		}

		return json({
			success: true,
			message: `Created ${count} test download codes`,
			codes: createdCodes,
			instructions: [
				'1. Visit the Downloads page at http://localhost:5174/downloads',
				'2. Enter one of the codes above',
				'3. Click Download to test the flow',
				'4. Check the download logs to verify tracking',
				'5. Try using the same code again to test one-time use'
			]
		});

	} catch (err) {
		console.error('Test setup error:', err);

		return json({
			success: false,
			message: 'Error creating test data',
			error: err instanceof Error ? err.message : 'Unknown error'
		}, { status: 500 });
	}
};

// Clear test data
export const DELETE: RequestHandler = async ({ platform }) => {
	try {
		const db = platform?.env?.DB;
		const bucket = platform?.env?.BUCKET;

		if (!db) {
			throw error(500, 'Database not available');
		}

		if (!bucket) {
			throw error(500, 'File storage not available');
		}

		// Only allow in development environments
		const nodeEnv = platform?.env?.NODE_ENV || 'local';
		if (nodeEnv === 'prod' || nodeEnv === 'production') {
			throw error(403, 'Test cleanup not allowed in production');
		}

		// Delete test download codes
		const codesResult = await executeWithRetry(db, `
			DELETE FROM download_codes WHERE created_by = 'test-setup'
		`);

		// Delete test download logs
		const logsResult = await executeWithRetry(db, `
			DELETE FROM download_log WHERE code_attempted LIKE '%TEST%' OR code_id IS NULL
		`);

		// List and delete test files from R2
		const testFiles = await bucket.list({ prefix: 'test-files/' });
		let deletedFiles = 0;

		for (const file of testFiles.objects) {
			await bucket.delete(file.key);
			deletedFiles++;
		}

		return json({
			success: true,
			message: 'Test data cleaned up successfully',
			deleted: {
				codes: codesResult.meta?.changes || 0,
				logs: logsResult.meta?.changes || 0,
				files: deletedFiles
			}
		});

	} catch (err) {
		console.error('Test cleanup error:', err);

		return json({
			success: false,
			message: 'Error cleaning up test data',
			error: err instanceof Error ? err.message : 'Unknown error'
		}, { status: 500 });
	}
};

// Get test data status
export const GET: RequestHandler = async ({ platform }) => {
	try {
		const db = platform?.env?.DB;

		if (!db) {
			throw error(500, 'Database not available');
		}

		// Get test codes count
		const codesResult = await executeWithRetry(db, `
			SELECT COUNT(*) as count FROM download_codes WHERE created_by = 'test-setup'
		`);

		// Get test logs count
		const logsResult = await executeWithRetry(db, `
			SELECT COUNT(*) as count FROM download_log
		`);

		return json({
			success: true,
			testData: {
				codes: (codesResult.results[0] as { count: number }).count,
				logs: (logsResult.results[0] as { count: number }).count
			},
			endpoints: {
				create: 'POST /api/downloads/test-setup',
				cleanup: 'DELETE /api/downloads/test-setup',
				status: 'GET /api/downloads/test-setup'
			}
		});

	} catch (err) {
		console.error('Test status error:', err);

		return json({
			success: false,
			message: 'Error checking test data status',
			error: err instanceof Error ? err.message : 'Unknown error'
		}, { status: 500 });
	}
};

// Handle CORS
export const OPTIONS: RequestHandler = async () => {
	return new Response(null, {
		status: 200,
		headers: {
			'Access-Control-Allow-Origin': '*',
			'Access-Control-Allow-Methods': 'GET, POST, DELETE, OPTIONS',
			'Access-Control-Allow-Headers': 'Content-Type',
		},
	});
};